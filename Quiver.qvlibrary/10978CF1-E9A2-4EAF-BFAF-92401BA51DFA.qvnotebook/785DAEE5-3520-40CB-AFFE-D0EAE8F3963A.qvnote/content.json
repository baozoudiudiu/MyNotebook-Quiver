{
  "title": "信号量浅析",
  "cells": [
    {
      "type": "markdown",
      "data": "> 信号量的使用类似GCD中的Group enter 和 Group leve. 会有一个成对的API\n**dispatch_semaphore_signal** 和 **dispatch_semaphore_wait**\n\n## 信号量的创建 **dispatch_semaphore_create**\n```\ndispatch_semaphore_t sema = dispatch_semaphore_create(0);\n\n/*\n括号里面的数字代表了信号量的初始值.\n当值为0时,dispatch_semaphore_wait后面的代码就不会被执行.直到信号量不为0\n*/\n```\n\n## 发送信号量dispatch_semaphore_signal\n```\ndispatch_semaphore_signal(sema)\n\n/*\n发送信号量,执行后信号量sema的值会+1\n*/\n```\n\n## 等待信号量 dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)\n```\ndispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);\n\n/*\n执行该代码,如果当前信号量sema值大于0,会将其-1,并执行后面的代码.\n如果当前sema值已经为0,则会一直处于等待状态,不会执行后面的代码.\n*/\n```\n\n## 使用场景实例一: 将异步变同步\n```\n    __block NSInteger testNumber = 1;\n    dispatch_semaphore_t sema = dispatch_semaphore_create(0);\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^{\n            testNumber += 1;\n            dispatch_semaphore_signal(sema);\n        });\n    });\n    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);\n    NSLog(@\"%ld\", testNumber);\n```\n上面这段代码如果没有信号量机制处理的话,控制台打印出来的应该是0,\n使用信号量机制后,控制台3秒后控制台输出的值为1.\n\n## 使用场景实例二: 限制并发数量\n```\n    dispatch_semaphore_t sema = dispatch_semaphore_create(2);\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^{\n            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);\n            NSLog(@\"11111\");\n            dispatch_semaphore_signal(sema);\n        });\n    });\n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^{\n            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);\n            NSLog(@\"22222\");\n            dispatch_semaphore_signal(sema);\n        });\n    });\n    \n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^{\n            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);\n            NSLog(@\"33333\");\n            dispatch_semaphore_signal(sema);\n        });\n    });\n    \n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^{\n            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);\n            NSLog(@\"44444\");\n            dispatch_semaphore_signal(sema);\n        });\n    });\n```\n创建了一个初始值为2的信号量.下面这四段代码块.一次只会同时执行2个.\n\n## 注意事项\n\n"
    }
  ]
}