{
  "title": "YYKit框架学习之YYCategory  -- UIView+YYAdd ",
  "cells": [
    {
      "type": "markdown",
      "data": "> 搞开发这么久了,很少去看一些大神的代码.后悔啊.希望现在亡羊补牢,为时不晚!\n\n# 这个是关于UIView的扩展 \n[作者官方文档](http://cocoadocs.org/docsets/YYCategories/1.0.4/Categories/UIView+YYAdd.html)\n- - -\n## 属性篇:\n| 属性名 | 解释 |\n| :----- | :--- |\n| bottom | frame.origin.y + frame.size.height |\n| centerX | center.x |\n| centerY | center.y |\n| height | frame.size.height |\n| left | frame.origin.x |\n| origin | frame.origin |\n| right | frame.origin.x + frame.size.width |\n| size | frame.size |\n| top | frame.origin.y |\n| viewController | 获取当前view所处的视图控制器 (下文有详解) |\n| visibleAlpha | 返回屏幕上的可见alpha,考虑superview和window (下文有详解) | \n| width | frame.size.width |\n> 其他的没什么好说的,这里说一下**visibleAlpha**和**viewController**两个属性\n> * viewController这个属性其实就是通过一层一层的遍历nextResponder,直到找到是UIViewController类型为止.这里涉及到\"响应链\"方面的知识点.\n> * visibleAlpha 其实看字面解释没太弄懂意思,你可以看下作者的源码实现.源码逻辑不涉及到任何技术点,会OC语法你就能看懂.源码如下:\n```\n- (CGFloat)visibleAlpha {\n    if ([self isKindOfClass:[UIWindow class]]) {\n        if (self.hidden) return 0;\n        return self.alpha;\n    }\n    if (!self.window) return 0;\n    CGFloat alpha = 1;\n    UIView *v = self;\n    while (v) {\n        if (v.hidden) {\n            alpha = 0;\n            break;\n        }\n        alpha *= v.alpha;\n        v = v.superview;\n    }\n    return alpha;\n}\n```\n> * 看完源码能够弄懂其中含义了(可视透明度,UIView 遍历到最后的根都是UIWindow\n这里用了透明度的累积), 应该是我比较菜吧,暂时不知道visibleAlpha的此段实现逻辑会在什么情况会用到.\n\n\n\n## 方法篇:\n| 方法名 | 类型 | 解释 |\n| :----- | :--: | :--- |\n| - (CGPoint)convertPoint:(CGPoint)point toViewOrWindow:(nullable UIView *)view | 实例方法 | 将基于调用者坐标系的point转换成基于view坐标系的point |\n| - (CGRect)convertRect:(CGRect)rect fromViewOrWindow:(nullable UIView *)view | 同上 | 将基于view坐标系的rect转换成相对于调用者坐标系的rect |\n| - (CGRect)convertRect:(CGRect)rect toViewOrWindow:(nullable UIView *)view | 同上 | 将基于调用者坐标系的rect转换成相对于view坐标系的rect |\n| - (void)removeAllSubviews | 同上 | 移除调用者所有的子视图 |\n| - (void)setLayerShadow:(nullable UIColor *)color offset:(CGSize)offset radius:(CGFloat)radius | 同上 | 设置shadow, 颜色, 偏移, 圆角 |\n| - (nullable UIImage *)snapshotImage | 同上 | 截图 |\n| - (nullable UIImage *)snapshotImageAfterScreenUpdates:(BOOL)afterUpdates | 同上 | 截图 It’s faster than “snapshotImage” |\n| - (nullable NSData *)snapshotPDF | 同上 | 转换成pdf |\n\n\n### 详解\n![图一](quiver-image-url/0E630441BD796968AF14DF9AF653C95A.png =372x817)\n如图: \n* 橙色的view,我们取名为orangeView(20, 80, 335, 200), orangeView添加在self.view上,(self是当前ViewController).\n* 黄色的view,我们取名为yellowView(10, 10, 30, 30), yellowView添加在orrangeView上.\n\n```\n    CGRect rect = [orangeView convertRect:CGRectMake(0, 0, 1, 1) fromViewOrWindow:self.view];\n    NSLog(@\"%@\", NSStringFromCGRect(rect));\n    // 输出为  {{-20, -80}, {1, 1}}\n    \n    CGPoint point = [orangeView convertPoint:CGPointMake(0, 0) fromViewOrWindow:self.view];\n    NSLog(@\"%@\", NSStringFromCGPoint(point));\n    // 输出为 {-20, -80}\n    \n    point = [orangeView convertPoint:CGPointMake(1, 1) toViewOrWindow:self.view];\n    NSLog(@\"%@\", NSStringFromCGPoint(point));\n    // 输出为 {21, 81}\n```\n---\n### -(void)setLayerShadow:(nullable UIColor *)color offset:(CGSize)offset radius:(CGFloat)radius\n这个设置阴影没什么好说的,不过阅读源码的时候发现了2句我之前没有用过的属性\n```\nself.layer.shouldRasterize = YES;\nself.layer.rasterizationScale = [UIScreen mainScreen].scale;\n```\n解释:\n> 光栅化\n《iOS 开发中的离屏渲染问题》中提到的 GPU 离屏渲染是自动触发的，而开启光栅化，是手动启动离屏渲染，并且将离屏渲染的工作交由 CPU 处理。\n> \n> 开启光栅化会将图层渲染为一个屏幕之外的位图(bitmap)，然后将这个位图缓存起来。图层有复杂的视觉效果，这样做就会比重绘所有帧划划算的多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。\n>\n> 当我们使用得当，光栅化可以提供很大的性能优势，但是一定要**避免用在内容是动态变化的图层上，不然它缓存方面的优势就会丧失，而且会让性能变的更糟**。**另外要注意的一点，设置 shouldRasterize 的同时也要设置 rasterizationScale。**\n\n上文解释中加粗的部分请额外注意.\n\n> 额外补充:\n> 最优设置\n在《iOS 性能优化之视图圆角》中提到了几种性能优化的方法，开启光栅化也能起到一定的性能优化作用。\n\n> 经过测试，对于 tableView 来说，光栅化性能最好的方式是是开启 cell 的 shouldRasterize，并将 rasterizationScale 设置为 UIScreen.main.scale。如果设置cell.layer.rasterizationScale = cell.layer.contentsScale则会出现视图模糊的现象。\n\n> cell.layer.shouldRasterize = true\n> cell.layer.rasterizationScale = UIScreen.main.scale\n若 cell 中有多个需要离屏渲染的子视图，对每个子视图分别开启光栅化并不会优化性能，反而可能造成性能下降。\n\n[参考文献](http://swift.diagon.me/shouldRasterize/)\n\n### 关于截屏- (nullable UIImage *)snapshotImageAfterScreenUpdates:(BOOL)afterUpdates\n> afterUpdates参数为YES，代表视图的属性改变渲染完毕后截屏，参数为NO代表立刻将当前状态的视图截图\n\n光看理论云里雾里? ok,我们直接撸代码(上方为视图view,下方为view的截图,点击开关的时候开始调用截图方法):\n* afterUpdates = NO\n![图二.gif](quiver-image-url/7F19F5206B8D94634CB8BC4FC9FD352A.gif =311x595)\n<br><br>\n* afterUpdates = YES;\n![图3.gif](quiver-image-url/E23DC1232D84419F53E7250766CDC5F8.gif =317x645)\n<br>\n看完上面的演示,原理一目了然.\n\n## 写在最后\n> 看到网上有部分较老的文章有提到UIView+YYAdd这个扩展和Masonry有冲突.什么self.left之类的使用失效问题.不过我看了最新的Masonry源码都加了前缀,现在都是mas_left之类.使用过程中目前我也没发现什么问题.这个问题应该是不会存在了."
    }
  ]
}